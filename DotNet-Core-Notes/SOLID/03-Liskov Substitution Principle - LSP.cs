 
📌 مبدأ استبدال ليسكوف (Liskov Substitution Principle - LSP) :

🔹 تعريف المبدأ
مبدأ استبدال ليسكوف (LSP) هو ثالث مبدأ من مبادئ SOLID، وينص على:

"يجب أن تكون الفئات الفرعية (Derived Classes) قادرة على استبدال الفئات الأساسية (Base Classes) دون التأثير على صحة البرنامج."

🔍 ماذا يعني ذلك؟
إذا كان لديك كلاس أساسي (Base Class) وكلاس فرعي (Derived Class)، فيجب أن يكون الكلاس الفرعي قابلًا للاستبدال بالكامل مكان الكلاس الأساسي دون تغيير السلوك المتوقع للبرنامج.

🔹 بعبارة أخرى:

عندما نستخدم كائنًا من الفئة الفرعية بدلًا من الفئة الأساسية، يجب ألا يتغير سلوك البرنامج أو ينهار.
يجب أن يكون الكود قادرًا على التعامل مع الكائنات من الفئات الفرعية بنفس طريقة التعامل مع الفئة الأساسية دون ظهور أخطاء غير متوقعة.


//==========================================================================================================================================
//==========================================================================================================================================

📌 لماذا نحتاج إلى مبدأ LSP؟
📍 تخيل هذا السيناريو:

لديك كلاس للأشكال الهندسية يحتوي على طريقة لحساب المساحة:

❌ قبل تطبيق مبدأ LSP (كود غير صحيح)

public class Rectangle
{
    public double Width { get; set; }
    public double Height { get; set; }

    public virtual double GetArea()
    {
        return Width * Height;
    }
}

الآن نريد إنشاء كلاس يمثل المربع (Square)، وبما أن المربع هو نوع خاص من المستطيل، فإننا نقوم بوراثة الكلاس المستطيل:


public class Square : Rectangle
{
    public override double Width
    {
        set { base.Width = base.Height = value; }
    }

    public override double Height
    {
        set { base.Width = base.Height = value; }
    }
}



//==========================================================================================================================================
//==========================================================================================================================================


⚠ المشكلة في هذا الكود!
إذا استخدمنا كائنًا من النوع Square مكان Rectangle، فإن طريقة حساب المساحة ستعطي نتائج خاطئة!

📍 مثال على المشكلة:


Rectangle rect = new Square();
rect.Width = 5;
rect.Height = 10;  // يجب أن يكون الارتفاع 10، ولكن الكود يجعل العرض = الارتفاع، أي 10!

Console.WriteLine(rect.GetArea()); // الناتج 100 بدلاً من 50! ❌


👀 المشكلة:

عندما قمنا بتغيير Width أو Height في Square، فإنه عدل القيمتين معًا، مما أدى إلى سلوك غير متوقع عند حساب المساحة.
المربع لا يمكن أن يكون بديلاً صحيحًا عن المستطيل!
✖ هذا انتهاك واضح لمبدأ LSP!


//==========================================================================================================================================
//==========================================================================================================================================

📌 كيف نطبق مبدأ استبدال ليسكوف بشكل صحيح؟
📍 بدلًا من جعل Square ترث Rectangle، يمكننا استخدام واجهة (Interface) أو كلاس أساسي أكثر عمومية:

✅ بعد تطبيق مبدأ LSP (كود صحيح ومُنظم)
🔹 نقوم بإنشاء كلاس أساسي Shape لكل الأشكال الهندسية، بحيث يحتوي فقط على GetArea() دون قيود على الأبعاد.


// كلاس عام للأشكال الهندسية
public abstract class Shape
{
    public abstract double GetArea();
}

// كلاس المستطيل
public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }

    public override double GetArea()
    {
        return Width * Height;
    }
}

// كلاس المربع
public class Square : Shape
{
    public double Side { get; set; }

    public override double GetArea()
    {
        return Side * Side;
    }
}


🔹 استخدام الكود الآن يكون أكثر استقرارًا:

Shape rect = new Rectangle { Width = 5, Height = 10 };
Shape square = new Square { Side = 5 };

Console.WriteLine(rect.GetArea());  // 50 ✅
Console.WriteLine(square.GetArea()); // 25 ✅


✅ الآن، كل فئة تقوم فقط بتنفيذ منطقها الخاص دون تغيير القيم بطريقة غير متوقعة.


//==========================================================================================================================================
//==========================================================================================================================================

📌 فوائد تطبيق مبدأ استبدال ليسكوف (LSP)
✅ 1. تجنب الأخطاء غير المتوقعة

لا يحدث تغيير غير متوقع في القيم أو في منطق الحساب عند استبدال الفئات الفرعية.
✅ 2. تحسين مرونة الكود

يمكننا بسهولة إضافة أنواع جديدة من الأشكال دون القلق من كسر الكود الموجود مسبقًا.
✅ 3. تعزيز القابلية لإعادة الاستخدام

يمكن إعادة استخدام Shape كأساس لأنواع متعددة من الأشكال الهندسية دون الحاجة إلى إعادة كتابة الشيفرة.
✅ 4. تسهيل الاختبار (Unit Testing)

يمكن اختبار كل كلاس بشكل مستقل دون الحاجة لاختبار تداخل القيم بين الفئات المختلفة.


//==========================================================================================================================================
//==========================================================================================================================================

📌 القاعدة الذهبية لمبدأ استبدال ليسكوف :

"يجب أن تتمكن الفئات الفرعية من استبدال الفئات الأساسية دون التأثير على منطق البرنامج."

✍ بتطبيق هذا المبدأ، نحصل على كود أكثر استقرارًا ومرونة، مما يسهل الصيانة والتطوير في المستقبل. 🚀


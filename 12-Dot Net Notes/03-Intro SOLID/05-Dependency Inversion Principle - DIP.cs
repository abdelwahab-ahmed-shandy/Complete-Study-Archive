
📌 مبدأ عكس الاعتمادية (Dependency Inversion Principle - DIP)
🔹 تعريف المبدأ
مبدأ عكس الاعتمادية (DIP - Dependency Inversion Principle) هو المبدأ الخامس والأخير من مبادئ SOLID، وينص على:

"يجب أن تعتمد الوحدات العليا (High-Level Modules) على التجريد (Abstractions)، وليس على الوحدات الدنيا (Low-Level Modules)."
"يجب ألا تعتمد التفاصيل على التفاصيل الأخرى، بل يجب أن تعتمد جميعها على التجريد."


//==========================================================================================================================================
//==========================================================================================================================================

🔍 ماذا يعني ذلك؟
عند تصميم الأنظمة، هناك نوعان من الوحدات:

1️⃣ الوحدات العليا (High-Level Modules)

تمثل المنطق الأساسي للنظام، مثل الخدمات والأعمال التجارية (Business Logic).
2️⃣ الوحدات الدنيا (Low-Level Modules)

تحتوي على التفاصيل الفعلية لتنفيذ المهام، مثل التعامل مع قواعد البيانات، الملفات، أو واجهات المستخدم.
🚨 المشكلة تحدث عندما تعتمد الوحدات العليا مباشرة على الوحدات الدنيا.

هذا يؤدي إلى ترابط قوي (Tight Coupling) بين الأجزاء المختلفة في النظام، مما يجعل التعديلات صعبة، ويؤثر على إعادة الاستخدام والصيانة.
الحل هو استخدام التجريد (Abstraction) بحيث تعتمد الوحدات العليا والدنيا على واجهة مشتركة بدلاً من أن تعتمد على بعضها البعض مباشرة.


//==========================================================================================================================================
//==========================================================================================================================================

📌 لماذا نحتاج إلى مبدأ DIP؟
عند كسر هذا المبدأ، يواجه النظام المشاكل التالية:

🔴 1. صعوبة التعديل والتطوير

أي تغيير في الوحدة الدنيا سيؤثر مباشرة على الوحدة العليا، مما يجعل النظام صعب الصيانة.
🔴 2. ضعف إمكانية إعادة الاستخدام

عندما تعتمد الوحدات العليا على تفاصيل محددة، يصبح من الصعب إعادة استخدام الكود في أماكن أخرى.
🔴 3. ضعف الاختبار (Testing)

عند إجراء اختبار الوحدة (Unit Testing)، يكون من الصعب استبدال الوحدات الدنيا بمزيفات (Mocks أو Stubs)، مما يعقد عملية الاختبار.


//==========================================================================================================================================
//==========================================================================================================================================

📌 مثال على كسر مبدأ DIP (كود غير صحيح) :

📍 تصميم خاطئ حيث تعتمد الوحدة العليا مباشرة على الوحدة الدنيا:


public class EmailService
{
    public void SendEmail(string message)
    {
        Console.WriteLine($"Sending Email: {message}");
    }
}

public class Notification
{
    private EmailService _emailService = new EmailService();

    public void Send(string message)
    {
        _emailService.SendEmail(message);
    }
}


⚠ المشكلة في هذا التصميم :

🔴 الوحدة العليا Notification تعتمد مباشرة على EmailService، مما يجعلها مقيدة بطريقة إرسال واحدة فقط (البريد الإلكتروني).
🔴 إذا أردنا دعم إرسال الإشعارات عبر SMS أو Push Notifications، سنحتاج إلى تعديل كود Notification نفسه، مما يخالف مبدأ الفتح/الإغلاق (OCP).
🔴 من الصعب اختبار Notification لأننا لا نستطيع استبدال EmailService بمزيفات (Mocks) أثناء الاختبار.


//==========================================================================================================================================
//==========================================================================================================================================

📌 الحل باستخدام مبدأ DIP (كود صحيح ومُنظم)
📍 بدلاً من الاعتماد على EmailService مباشرة، نقوم بتعريف واجهة INotificationSender، بحيث يمكن لأي نوع من الخدمات (Email, SMS, Push) تنفيذها.

✅ تصميم صحيح باستخدام مبدأ DIP


// واجهة مجردة لإرسال الإشعارات
public interface INotificationSender
{
    void Send(string message);
}

// تنفيذ الإشعارات عبر البريد الإلكتروني
public class EmailService : INotificationSender
{
    public void Send(string message)
    {
        Console.WriteLine($"Sending Email: {message}");
    }
}

// تنفيذ الإشعارات عبر الرسائل القصيرة SMS
public class SMSService : INotificationSender
{
    public void Send(string message)
    {
        Console.WriteLine($"Sending SMS: {message}");
    }
}

// تنفيذ الإشعارات عبر Push Notifications
public class PushNotificationService : INotificationSender
{
    public void Send(string message)
    {
        Console.WriteLine($"Sending Push Notification: {message}");
    }
}

// الوحدة العليا تعتمد الآن على التجريد وليس على التفاصيل
public class Notification
{
    private readonly INotificationSender _notificationSender;

    // حقن التبعية عبر المُنشئ (Constructor Injection)
    public Notification(INotificationSender notificationSender)
    {
        _notificationSender = notificationSender;
    }

    public void Send(string message)
    {
        _notificationSender.Send(message);
    }
}


----------------------------------------------------------
----------------------------------------------------------
----------------------------------------------------------
📌 كيف يعمل هذا التصميم؟

1️⃣ أنشأنا واجهة INotificationSender لتكون تجريدًا مشتركًا لجميع طرق الإشعارات.

2️⃣ كل نوع من الإشعارات (Email, SMS, Push) يقوم بتنفيذ INotificationSender بدلاً من الاعتماد على Notification مباشرة.

3️⃣ الوحدة العليا Notification تعتمد الآن على التجريد (INotificationSender) بدلاً من التفاصيل (EmailService).

4️⃣ يمكننا بسهولة إضافة طرق جديدة دون تعديل Notification، مما يجعل الكود مفتوحًا للامتداد ومغلقًا للتعديل (OCP).


//==========================================================================================================================================
//==========================================================================================================================================

📌 فوائد تطبيق مبدأ DIP :


✅ 1. تقليل الترابط القوي (Loose Coupling)

الوحدات العليا والدنيا تعتمد على التجريد بدلاً من الاعتماد المباشر، مما يجعل الكود أكثر مرونة.
✅ 2. سهولة التعديل والتوسيع

يمكننا إضافة أنواع جديدة من الإشعارات دون تعديل الوحدة Notification، مما يسهل صيانة النظام.
✅ 3. تحسين قابلية الاختبار (Testability)

يمكننا بسهولة استخدام Mocks أو Stubs لاختبار Notification دون الحاجة إلى تنفيذ EmailService الحقيقي.
✅ 4. تحسين إعادة الاستخدام (Reusability)

يمكننا استخدام INotificationSender في مشاريع مختلفة وإعادة استخدامها مع وحدات أخرى.


//==========================================================================================================================================
//==========================================================================================================================================

📌 القاعدة الذهبية لمبدأ عكس الاعتمادية (DIP)
"يجب أن تعتمد الوحدات العليا والدنيا على التجريد، وليس على التفاصيل."

🚀 بتطبيق هذا المبدأ، يصبح الكود أكثر مرونة، وسهل التطوير، والتوسع دون التسبب في مشاكل في النظام!